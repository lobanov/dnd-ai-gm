import { useState } from 'react';
import { LLMClient, UIMessage, LLMMessage } from './types';
import { useGameStore } from '@/lib/store';

interface UseLLMProps {
    client: LLMClient;
    onError?: (error: Error) => void;
}

export function useLLM({ client, onError }: UseLLMProps) {
    const [isLoading, setIsLoading] = useState(false);

    const {
        character,
        llmHistory,
        addUIMessage,
        addLLMMessage,
        setLLMHistory,
        setCurrentActions
    } = useGameStore();

    const sendMessage = async (content: string, options?: { hidden?: boolean }) => {
        if (!content.trim()) return;

        setIsLoading(true);

        // 1. Add User Message to UI and LLM history
        const userUIMsg: UIMessage = {
            id: crypto.randomUUID(),
            role: 'user',
            content,
            timestamp: Date.now()
        };

        const userLLMMsg: LLMMessage = {
            role: 'user',
            content
        };

        if (!options?.hidden) {
            addUIMessage(userUIMsg);
        }
        addLLMMessage(userLLMMsg);

        try {
            // 2. Call LLM with updated history
            // We need to pass the history *including* the new message
            // Since state updates are async, we construct the new history manually for the call
            const currentLLMHistory = [...llmHistory, userLLMMsg];

            const response = await client.sendMessage(currentLLMHistory, character);

            // 3. Handle Response

            // Update LLM History with all the new turns (narrative + tools)
            // We append the new messages to the store
            // Note: response.llmHistoryUpdates contains the *new* messages generated by the LLM
            const newLLMMessages = response.llmHistoryUpdates;

            // We can batch add or set the history. 
            // Since we have the previous history + user msg + new msgs:
            setLLMHistory([...currentLLMHistory, ...newLLMMessages]);

            // Process tool calls for UI display (e.g. GM rolling dice)
            // We look for 'tool' messages which contain the result of a tool call
            // We can also look at the assistant message that *called* the tool to get the arguments
            // But the tool result message is the most definitive "it happened" signal.

            // However, to show "GM rolled 1d20", we need the arguments from the assistant message.
            // Let's iterate through the new messages.
            for (let i = 0; i < newLLMMessages.length; i++) {
                const msg = newLLMMessages[i];
                if (msg.role === 'assistant' && msg.tool_calls) {
                    for (const toolCall of msg.tool_calls) {
                        if (toolCall.function.name === 'roll_dice') {
                            try {
                                const args = JSON.parse(toolCall.function.arguments);
                                // Find the corresponding tool result
                                const toolResultMsg = newLLMMessages.find(
                                    m => m.role === 'tool' && m.tool_call_id === toolCall.id
                                );

                                if (toolResultMsg && toolResultMsg.content) {
                                    const result = JSON.parse(toolResultMsg.content);

                                    // Only display roll if we have valid data
                                    if (args?.dice && result?.total != null) {
                                        // Create a UI message for this roll
                                        const rollUIMsg: UIMessage = {
                                            id: crypto.randomUUID(),
                                            role: 'system', // Use system role for GM mechanics
                                            content: `ðŸŽ² **GM Rolled ${args.dice}**: ${result.total}`,
                                            timestamp: Date.now()
                                        };
                                        addUIMessage(rollUIMsg);
                                    }
                                }
                            } catch (e) {
                                console.error('Failed to parse tool call for UI', e);
                            }
                        }
                    }
                }
            }

            // Add Narrative to UI
            const assistantUIMsg: UIMessage = {
                id: crypto.randomUUID(),
                role: 'assistant',
                content: response.message.content,
                timestamp: Date.now()
            };
            addUIMessage(assistantUIMsg);

            // Set Actions
            if (response.message.actions) {
                setCurrentActions(response.message.actions);
            }

        } catch (error: any) {
            console.error('Conversation error:', error);
            if (onError) onError(error);
        } finally {
            setIsLoading(false);
        }
    };

    return {
        sendMessage,
        isLoading
    };
}
